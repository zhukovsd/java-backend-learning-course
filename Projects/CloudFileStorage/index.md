# Проект "облачное хранилище файлов"

Многопользовательское файловое облако. Пользователи сервиса могут использовать его для загрузки и хранения файлов. Источником вдохновения для проекта является Google Drive.

## Что нужно знать

- [Java]({{ site.baseurl }}/Technologies/Java/) - коллекции, ООП
- [Maven/Gradle]({{ site.baseurl }}/Technologies/BuildSystems/)
- [Backend]({{ site.baseurl }}/Technologies/Backend/)
  - Spring Boot, Spring Security, Spring Sessions
  - Thymeleaf
  - Upload файлов, заголовки HTTP запросов, cookies, cессии
- [Базы данных]({{ site.baseurl }}/Technologies/Databases/)
  - SQL
  - Spring Data JPA
  - Представление о NoSQL хранилищах
- HTML/CSS
- Docker (контейнеры, образы, volumes), Docker Compose

## Мотивация проекта

- Использование возможностей Spring Boot
- Практика с Docker и Docker Compose
- Первый проект где студент самостоятельно разрабатывает структуру БД
- Знакомство с NoSQL хранилищами - S3 для файлов, Redis для сессий

## Функционал приложения

Работа с пользователями:

- Регистрация
- Авторизация
- Logout

Работа с файлами и папками:

- Загрузка файлов и папок
- Создание новой пустой папки (аналогично созданию новой папки в проводнике)
- Удаление
- Переименование

## Интерфейс приложения

### Главная страница

Адрес - `/?path=$path_to_subdirectory`. Параметр `$path` задаёт путь просматривамой папки. Если параметр отсутствует, подразумевается корневая папка. Пример - `/path=Projects%2FJava%2FCloudFileStorage` (параметр закодирован через URL Encode).

- Заголовок
    - Для неавторизованных пользователей - кнопки регистрации и авторизации
    - Для авторизованных пользователей - логин текущего пользователя и кнопка Logout
- Контент (только для авторизованных пользователей)
    - Форма поиска файлов и папок по названию
    - Навигационная цепочка (breadcrumbs), содержащая путь из папок до текущей папки. Каждый элемент явлеятся ссылкой на свою папку. Пример - цепочка из папок, ведущая к - `Projects/Java/CloudFileStorage` содержала бы 3 папки - корневую, `Projects` и `Projects/Java`
    - Список файлов в текущей директории. Для каждого файла отображаем имя и кнопку, вызывающее меню действий (удаление, переименование)
    - Формы (или drop areas) для загрузки файлов и папок

### Страница поиска файлов

Адрес - `/search/?query=$search_query`.

- Заголовок
    - Для неавторизованных пользователей - кнопки регистрации и авторизации
    - Для авторизованных пользователей - логин текущего пользователя и кнопка Logout
- Контент
    - Форма поиска файлов и папок по названию
    - Список найденных файлов. Для каждого найденного файла отображаем имя и кнопку для перехода в папку, содержащую данный файл

Неавторизованные пользователя не имеют доступа к данной странице, приложение должно редиректить их на форму авторизации.

### Контроллер для доступа к конкретному файлу

### Остальное

- Страницы с формами регистрации и авторизации

## Работа с сессиями, авторизацией, регистрацией

В предыдущем проекте мы управляли сессиями пользователей вручную, в этом проекте воспользуемся возможности экосистемы Spring Boot.

За авторизацию, управление доступом к страницам отвечает Spring Security.

За работу с сессиями отвечает Spring Sessions. По умолчанию Spring Boot хранит сессии внутри приложения, и они теряются после каждого перезапуска приложения. Мы воспользуемся Redis для хранения сессий. Пример - [https://www.baeldung.com/spring-session](https://www.baeldung.com/spring-session). Redis - NoSQL хранилище, имеющее встроенный TTL (time to live) атрибут для записей, что делает его удобным для хранения сессий - истекшие сессии автоматически удаляются. 

## SQL база данных

В этом проекте студент самостоятельно разрабатывает структуру базы данных для хранения пользователей (файлы и сессии распологаются в других хранилищах). Предлагаю использовать MySQL.

Ориентироваться стоит на интеграцию с Spring Security. Эта библиотека экосистемы Spring подразумевает определённые атрибуты, которыми должен обладать пользователь, и список которых и станет основой колонок для таблицы `Users`.

Пример интеграции между Spring Security и Spring Data JPA - [https://www.baeldung.com/registration-with-spring-mvc-and-spring-security](https://www.baeldung.com/registration-with-spring-mvc-and-spring-security).

Важно помнить о создании необходимых индексов в таблице `Users`. Например, логин пользователя должен быть уникальным.

## Хранилище файлов S3

Для хранения файлов будем пользоваться S3 - simple storage service. Проект, разработанный Amazon Cloud Services, представляет из себя облачный сервис и протокол для файлового хранилища. Чтобы не зависеть от платных сервисов Amazon в этом проекте, воспользуемся альтернативным S3-совместимым хранилищем, которое можно запустить локально - [https://min.io/](https://min.io/)

- Докер образ для локального запуска MinIO - [https://hub.docker.com/r/minio/minio/](https://hub.docker.com/r/minio/minio/)
- Для работы с протоколом S3 воспользуемся AWS Java SDK, пример - [https://docs.min.io/docs/how-to-use-aws-sdk-for-java-with-minio-server.html](https://docs.min.io/docs/how-to-use-aws-sdk-for-java-with-minio-server.html)

### Структура S3 хранилища

В SQL мы оперируем таблицами, в S3 таблиц не существует, вместо этого S3 оперирует бакетами (bucket - корзина) с файлами. Чтобы понять что такое бакет, можно провести аналогию с диском или флешкой.

Внутри бакета можно создавать файлы и папки.

Для хранения файлов всех пользователей в проекте создадим для них бакет под названием `user-files`. В корне бакета для каждого пользователя будет создана папка с именем в формате `user-${id}-files`, где `id` является идентификатором пользователя из SQL базы.

Каждая из таких папок является корнем для хранения папок данного пользователя. Пример - файл `docs/test.txt` пользователя с id `1` должен быть сохранён в путь `user-1-files/docs/test.txt`.

### Работа с S3 из Java

Как было упомянуто выше, для работы с S3 воспользуемся AWS Java SDK. Необходимо будет научиться пользоваться этот библиотекой, чтобы:
- Создавать файлы
- Переименовывать файлы
- "Переименовывать" папки. Насколько знаю в S3 нет такой операции, переименование папки по сути представляет собой создание папки под новым именем и перенос туда файлов
- Удалять файлы

## Upload файлов

Для загрузки файлов необходимо воспользоваться HTML file input - [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file). Рапространённый подход оформить это в виде зоны, на которую можно перетягивать файлы из проводника, пример - [https://codepen.io/dcode-software/pen/xxwpLQo](https://codepen.io/dcode-software/pen/xxwpLQo).

На уровне HTTP, передача файлов осуществляется с помощью `multipart/form-data`.

Со стороны Spring Boot необходимо будет реализовать контроллер(ы) для обработки загруженных файлов. Важно иметь ввиду, что по-умолчанию лимит на загрузку файлов в Spring Boot равен 10 мегабайтам, но его можно увеличить.

### Загрузка папок

File input может быть использован для загрузки либо отдельных файлов, либо папок (если у input установлен атрибут [webkitdirectory](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#webkitdirectory), но не одновременно.

Получается, что необходимо иметь 2 input'а - для файлов, и для папок. Возможно, существуют Javascript библиотеки, которые решают этот вопрос и реализуют единый input для обоих случаев.

## Docker

В данном проекте впервые воспользуемся Docker для удобного запуска необходимых приложений - SQL базы, файлового хранилища MinIO и хранилища сессий Redis.

Необходимо:
- Найти образы для каждого нужного приложения из списка выше
- Написать Docker Compose файл для запуска стека с приложениями (по контейнеру для каждого)
- Знать Docker Compose команды для работы со стеком

Как будет выглядеть работа с Docker:
- Для работы над проектом запускаем стек из контейнеров
- Уничтожаем или останавливаем контейнеры (с сохранением данных на volumes), когда работа не ведётся
- По необходимости уничтожаем данные на volumes, если хотим очистить то или иное хранилище

## Деплой

Будем вручную деплоить jar артефакт. Для его запуска не требуется Tomcat, потому что в собранное Spring Boot приложение уже встроен веб-сервер. Все остальные приложения этого проекта (SQL, Redis, MinIO) запускаем через Docker Compose.

Шаги:
- Локально собрать jar артефакт приложения
- В хостинг-провайдере по выбору арендовать облачный сервер на Linux
- Установить JRE, Docker
- Скопировать на удалённый сервер Docker Compose файл для запуска MySQL, Redis, MinIO
- Скопировать на удалённый сервер локально собранный jar, запустить

Ожидаемый результат - приложение доступно по адресу `http://$server_ip:8080/$app_root_path`.

## План работы над приложением

- Docker Compose - добавить MySQL
- Spring Boot - с помощью Spring Security, Thymeleaf и Spring Data JPA реализовать регистрацию и авторизацию пользователей
- Docker Compose - добавить MinIO
- Spring Boot - интегрировать AWS Java SDK и научиться совершать операции с файлами в бакете, написать сервис, инкапсулирующий необходимые для приложения операции
- Реализовать загрузку файлов и папок через форму (формы) на главной странице
- Реализовать отображение файлов и навигацию по структуре директорий, действия с файлами (удаление, переименование)
- Поиск файлов - сервис, контроллер и Thymeleaf шаблон
- Docker Compose - добавить Redis
- Spring Sessions - сконфигурировать хранение сессий внутри Redis
- Деплой
